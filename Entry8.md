# Learning and Relearning
In the process of begining to study for finals, I have come across lots of notes and concepts from the begining semester that I realized I needed a refresher on. Now,
given that learning these concepts was a very daunting task at first, I was a little worried about having to almost "relearn" some of these topics. However, when I actually went
to reteach myself, I not only was able to recall what I had learned on my first pass through these subjects, but I was better able to see the connections between what we did then
and what we did at the end of the class, so I figured I would use this blog post to briefly discuss them!


## Parse trees and Interpreters
Interpreters and Parse trees were two topics in particular from the begining of the class that I had some difficulty with, but my limited knowledge was enough to get by at the begining.
For whatever reason, I just could not wrap my head around their uses and how exactly they are structured. Going back through the notes and watching the videos provided for the class, essentially looking at it with a fresh pair of eyes,
I was able to gain a much deeper understanding of how functional programming languages are constructed. Admittedly, my way of doing the assignments for this class was simply lots of trial
and error as I wasnt able to really understand exactly how the lambdanat interpreters and other files achieved their functionality, just what they do. It resulted in
my assignments sort of just being this collage of guesses at the right way to do things that (usually) worked out ok. Having this new understanding of how they work though
allowed me to take a deeper dive into what exactly each of my assignments was doing, and this added clarity made what was a rather painstaking process seem like something I could achieve twice as fast.
I was able to understand exactly how the lambdanat language was processing and interpreting each line of my code.


## Precendence Levels
Another topic I had trouble remebering, which granted is related to interpreters, was precedence levels. I actually didnt have a ton of trouble with this
on my first attempt. The idea seemed simple enough, it was a system that lets the programmer define the order of operations for the interpreter. I was able to figure out
what the parser would need to look like for a few simple equations and I was satisfied with my knowledge of them. However when it came time for the actual assignments where we
needed to implement them, I had more trouble. To rectify this, I again went and looked through old notes and videos. That helped jog my memory, but I was still stuck on how to implement them
for something more complex. My solution essentially was to just continue to grind through example after example equation, increasing them in complexity as I went.
This solved all my issues with understanding, and when I looked back at the one I had struggled so desperatley to write for assignment 2, it seemed like it would be a cakewalk. Even to the point
where I tried to recreate the solution using the stuff I learned through my studying.
